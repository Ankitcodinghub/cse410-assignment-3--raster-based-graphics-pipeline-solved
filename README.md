# cse410-assignment-3--raster-based-graphics-pipeline-solved
**TO GET THIS SOLUTION VISIT:** [CSE410 Assignment 3- Raster Based Graphics Pipeline Solved](https://www.ankitcodinghub.com/product/cse410-assignment-3-raster-based-graphics-pipeline-solved/)


---

ğŸ“© **If you need this solution or have special requests:** **Email:** ankitcoding@gmail.com  
ğŸ“± **WhatsApp:** +1 419 877 7882  
ğŸ“„ **Get a quote instantly using this form:** [Ask Homework Questions](https://www.ankitcodinghub.com/services/ask-homework-questions/)

*We deliver fast, professional, and affordable academic help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;93310&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;0&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;0&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;0\/5 - (0 votes)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;CSE410 Assignment 3- Raster Based Graphics Pipeline Solved&quot;,&quot;width&quot;:&quot;0&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 0px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            <span class="kksr-muted">Rate this product</span>
    </div>
    </div>
<div class="page" title="Page 1">
<div class="layoutArea">
<div class="column">
&nbsp;

</div>
</div>
<div class="layoutArea">
<div class="column">
In this assignment, you will develop the raster based graphics pipeline used in OpenGL. The pipeline can be thought of as a series of four stages:

<ol>
<li>Stage 1: modeling transformation</li>
<li>Stage 2: view transformation</li>
<li>Stage 3: clipping and projection transformation</li>
<li>Stage 4: scan conversion using z-buffer algorithm</li>
</ol>
Your program will output four files: stage1.txt, stage2.txt, stage3.txt and out.bmp. The first three files will contain the output of the first three stages, respectively. The fourth file will be a bmp image generated by the pipeline.

Scene description:

You will be given a text file named â€œscene.txtâ€. This will contain the following lines:

Line 1: eyeX eyeY eyeZ

Line 2: lookX lookY lookZ

Line 3: upX upY upZ

Line 4: fovY aspectRatio near far Line 5: screen_width screen_height Line 6: r g b

eyeX, eyeY and eyeX are eye position. lookX, lookY, lookZ denote 3D point where eye is looking. upX, upY and upZ are the up vector. These nine numbers are the nine parameters of the gluLookAt function.

Line 4 gives the field of view along Y axis, followed by the aspect ratio. Following two numbers indicate the near and far plane.

Line 5 contains two integers that indicate the size of the image. Then, line 6 contains r g b which denote the components of background color and can have any integer value between 0 and 255.

</div>
</div>
</div>
<div class="page" title="Page 2">
<div class="layoutArea">
<div class="column">
The rest of scene.txt contains the display code to generate/draw the model. The display code contains 7 commands as follows:

<ol>
<li>triangle command â€“ this command is followed by four lines. The first three lines specify the coordinates of the three points of the triangle to be drawn. The points being p1, p2, and p3, 9 double values, i.e., p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, and p3.z indicate the coordinates. This is equivalent to the following in OpenGL code.
<pre>           glBegin(GL_TRIANGLE);{
                glVertex3f(p1.x, p1.y, p1.z);
                glVertex3f(p2.x, p2.y, p2.z);
                glVertex3f(p3.x, p3.y, p3.z);
</pre>
}glEnd();

The fourth line contains the r, g, b values of the triangle respectively, and can have any integer value with in range 0 and 255.
</li>
<li>translate command â€“ this command is followed by 3 double values (tx, ty, and tz) in the next line indicating translation amounts along X, Y, and Z axes. This is equivalent to glTranslatef(tx, ty, tz)inOpenGL.</li>
<li>scale command â€“ this command is followed by 3 double values (sx, sy, and sz) in the next line indicating scaling factors along X, Y, and Z axes. This is equivalent to glScalef(sx, sy, sz) in OpenGL.</li>
<li>rotate command â€“ this command is followed by 4 double values in the next line indicating the rotation angle in degree (angle) and the components of the vector defining the axis of rotation(ax, ay, and az). This is equivalent to glRotatef(angle, ax, ay, az) in OpenGL.</li>
<li>push command â€“ This is equivalent to glPushMatrix in OpenGL.</li>
<li>pop command â€“ This is equivalent to glPopMatrix in OpenGL.</li>
<li>end command â€“ This indicates the end of the display code.</li>
</ol>
Please check the scene.txt carefully to have a more comfortable understanding of the input.

</div>
</div>
</div>
<div class="page" title="Page 3">
<div class="layoutArea">
<div class="column">
Stage 1: Modeling Transformation

In the Modeling transformation phase, the display code in scene.txt is parsed, the transformed positions of the points that follow each triangle command are determined, and the transformed coordinates of the points are written in stage1.txt file. We maintain a stack S of transformation matrices which is manipulated according to the commands given in the display code. The pseudo-code for the modeling transformation phase is as follows:

<pre>     initialize empty stack S
     S.push(identity matrix)
     while true
</pre>
<pre>           input command
           if command = â€œtriangleâ€
</pre>
<pre>                input three points and the color of the triangle
                for each of these three point P
</pre>
<pre>                      Pâ€™ &lt;- transformPoint(S.top,P)
</pre>
<pre>                      output Pâ€™
           else if command = â€œtranslateâ€
</pre>
input translation amounts

generate the corresponding translation matrix T S.push(product(S.top,T))

<pre>           else if command = â€œscaleâ€
                input scaling factors
</pre>
<pre>                generate the corresponding scaling matrix T
</pre>
<pre>                S.push(product(S.top,T))
           else if command = â€œrotateâ€
</pre>
<pre>                input rotation angle and axis
                generate the corresponding rotation matrix T
                S.push(product(S.top,T))
</pre>
<pre>           else if command = â€œpushâ€
                //do it yourself
</pre>
<pre>           else if command = â€œpopâ€
                //do it yourself
</pre>
<pre>           else if command = â€œendâ€
                break
</pre>
</div>
</div>
</div>
<div class="page" title="Page 4">
<div class="layoutArea">
<div class="column">
Transformation matrix for Translation

<pre>translate
tx ty tz
</pre>
The transformation matrix for the above translation is as follows:

</div>
</div>
<div class="layoutArea">
<div class="column">
Transformation matrix for Scaling

scale

sx sy sz

</div>
</div>
<div class="layoutArea">
<div class="column">
1 0 0 tx 0 1 0 ty 0 0 1 tz 0001

</div>
</div>
<div class="layoutArea">
<div class="column">
The transformation matrix for the above scaling is as follows:

sx 0 0 0 0 sy 0 0 0 0 sz 0 0001

Transformation matrix for Rotation

Remember that, the columns of the rotation matrix indicate where the unit vectors along the principal axes (namely, i, j, and k) are transformed. We will use the vector form of Rodrigues formula to determine where i, j, and k are transformed and use those to generate the rotation matrix. The vector form of Rodrigues formula is as follows:

R(ğ‘¥âƒ—,ğ‘âƒ—,Î¸) = cosÎ¸ğ‘¥âƒ— + (1-cosÎ¸)(ğ‘âƒ—.ğ‘¥âƒ—)ğ‘âƒ— + sinÎ¸(ğ‘âƒ—Xğ‘¥âƒ—)

In the above formula, ğ‘âƒ— is a unit vector defining the axis of rotation, Î¸ is the angle of rotation, and ğ‘¥âƒ— is the

vector to be rotated.

Now we outline the process of generating transformation matrix for the following rotation:

<pre>rotate
angle ax ay az
</pre>
We denote the vector (ax, ay, az) by a. The steps to generate the rotation matrix are as follows:

<pre>a.normalize()
c1=R(i,a,angle)
c2=R(j,a,angle)
c3=R(k,a,angle)
</pre>
</div>
</div>
</div>
<div class="page" title="Page 5">
<div class="layoutArea">
<div class="column">
The corresponding rotation matrix is given below:

c1.x c2.x c3.x 0 c1.y c2.y c3.y 0 c1.z c2.z c3.z 0

0001

Managing Push and Pop

The following table demonstrates how push and pop works. The state of the transformation matrix stack after execution of each line of the code in the left is shown in the right. Design a data structure that manages push and pop operations on the transformation matrix stack accordingly.

Stack State after Lines

Code 0 1 2 3 4 5 6 7 8 9 10 11

</div>
</div>
<div class="layoutArea">
<div class="column">
1.Push

2.Translate1

3.Push

4.Rotate1

5.Pop

6.Scale1

7.Push

8.Rotate2

9.Pop

10.Scale2

11.Pop IIIIIIIIIIII

</div>
</div>
<div class="layoutArea">
<div class="column">
T1R1

T1 T1

</div>
<div class="column">
T1S1R2 T1S1 T1S1 T1S1

</div>
<div class="column">
T1S1S2 T1S1 T1S1

</div>
</div>
<div class="layoutArea">
<div class="column">
T1

</div>
<div class="column">
T1

</div>
<div class="column">
T1 T1 T1

</div>
<div class="column">
T1 T1

</div>
</div>
</div>
<div class="page" title="Page 6">
<div class="layoutArea">
<div class="column">
Stage 2: View Transformation

In the view transformation phase, the gluLookAt parameters in scene.txt is used to generate the view transformation matrix V, and the points in stage1.txt are transformed by V and written in stage2.txt. The process of generating V is given below.

</div>
</div>
<div class="layoutArea">
<div class="column">
First determine mutually perpendicular unit vectors l, r, and u

l = look â€“ eye l.normalize() r = l X up r.normalize() u=rXl

</div>
<div class="column">
from the gluLookAt

</div>
<div class="column">
parameters.

</div>
</div>
<div class="layoutArea">
<div class="column">
Apply the following translation T to move the eye/camera to origin.

ïƒ©1 0 0 ï€­eyeXïƒ¹ ïƒª0 1 0 ï€­eyeYïƒº ïƒª0 0 1 ï€­eyeZïƒº ïƒ«0 0 0 1 ïƒ»

</div>
</div>
<div class="layoutArea">
<div class="column">
Apply the following rotation R such that the l aligns with the -Z axis, r with X axis, and u with Y axis. Remember that, the rows of the rotation matrix contain the unit vectors that align with the unit vectors along the principal axes after transformation.

ïƒ© r.x r.y r.z 0ïƒ¹ ïƒª u.x u.y u.z 0ïƒº ïƒªï€­l.x ï€­l.y ï€­l.z 0ïƒº ïƒ«0 0 0 1ïƒ»

Thus the view transformation matrix V=RT.

</div>
</div>
</div>
<div class="page" title="Page 7">
<div class="layoutArea">
<div class="column">
Stage 3: Clipping and Projection Transformation

Projection Transformation:

In the projection transformation phase, the gluPerspective parameters in scene.txt are used to

</div>
</div>
<div class="layoutArea">
<div class="column">
generate the projection transformation matrix P, and the points in stage2.txt and written in stage3.txt. The process of generating P is as follows:

</div>
<div class="column">
are transformed by P

</div>
</div>
<div class="layoutArea">
<div class="column">
First compute the field of view along X axis (fovX) and determine r

<pre>     fovX = fovY * aspectRatio
     t = near * tan(fovY/2)
     r = near * tan(fovX/2)
</pre>
The projection matrix P is given below: ïƒ©near/r 0 0

</div>
<div class="column">
and t.

</div>
</div>
<div class="layoutArea">
<div class="column">
ïƒª 0 near/t 0

ïƒª 0 0 ï€­(farï€«near)/(farï€­near) ïƒ«00ï€­1 0ïƒ»

Clipping:

Having introduced the projection transformation, we can now introduce the fact that no point on xy plane can exist when we are trying to perform projection. (Refer to theory class for details). Therefore, before projection, you must clip everything with respect to near and far planes accordingly.

In this assignment, after view transformation, the camera is looking at â€“Z axis. Therefore, clipping with respect to z=-near is crucial before projection. However, we will perform clipping with respect to both z=-near and z=-far before projection. After clipping, the projected points will be outputted to stage3.txt.

PS: We also need to clip everything with respect to x and y axes as well (outside the field of view). These will be taken care of in the later stage.

Now, anything having z-value greater than (near) or less than (far) need to be clipped.

</div>
</div>
<div class="layoutArea">
<div class="column">
0

</div>
<div class="column">
ïƒ¹

</div>
</div>
<div class="layoutArea">
<div class="column">
0

ï€­(2* far*near)/(farï€­near)ïƒº

</div>
</div>
<div class="layoutArea">
<div class="column">
ïƒº

</div>
</div>
</div>
<div class="page" title="Page 8">
<div class="layoutArea">
<div class="column">
You may need to perform the clipping more than once on the same set of triangles, depending on how many points lie outside the clip region. Refer to class lecture for details.

</div>
</div>
</div>
<div class="page" title="Page 9">
<div class="layoutArea">
<div class="column">
Stage 4: Scan Conversion

If you are done with step 1, your next step will start from the output of stage 3. After projection transformation, everything that will be visible will have all of x,y and z coordinates in [-1,1]. Since you have already performed clipping with respect to z-axis, z co-ordinates will be within this range by now.

Now, let us consider the plane as a square of length 2 on xy plane:

Now, divide the projection plane into a two dimensional grid of screen_width x screen_height. You have to calculate the center point of each small square to find out the color in the corresponding pixel. Construct a pixel buffer and a z-buffer of the same dimension and initialize them with appropriate values.

Now, you are ready for applying the z-buffer algorithm. Using the z-buffer algorithm, you will scan convert each triangle to fill up the pixel buffer.

</div>
</div>
</div>
<div class="page" title="Page 10">
<div class="layoutArea">
<div class="column">
The steps are as follow:

<ul>
<li>ï‚· &nbsp;Each scan-line will intersect a triangle in at most two points. Find the co-ordinates from the coordinates of the vertices using linear interpolation.</li>
<li>ï‚· &nbsp;Find out the pixel position of the left intersection point and compare the z-value from the Z- buffer. If required conditions are satisfied, put the color of the triangle in the corresponding position of the pixel buffer and update the Z-buffer.</li>
<li>ï‚· &nbsp;Move one pixel right and calculate the z-value at that position from linear interpolation of the two intersection points.</li>
<li>ï‚· &nbsp;Repeat this step till you get to the right intersection point.</li>
<li>ï‚· &nbsp;At any point, if x or y value is outside [-1,1], discard it. This automatically takes care of the
clipping.
</li>
<li>ï‚· &nbsp;Handle special cases of a single intersection point and intersecting a horizontal line.</li>
<li>ï‚· &nbsp;Take some precautions to avoid precision related issues. Consider a small margin for floating
point comparisons.
</li>
<li>ï‚· &nbsp;Finally save the pixel buffer as an image. The code for saving image is already in the given
template.
</li>
</ul>
</div>
</div>
</div>
